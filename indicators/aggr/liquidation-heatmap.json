{
  "type": "indicator",
  "name": "indicators:Liquidation Heatmap",
  "data": {
    "options": {
      "priceScaleId": "right",
      "type": 0
    },
    "script": "leverages = option(default=5 | 20 | 100, type = text, description = \"Set leverage levels to simulate (use | or , separator, e.g., 5|20|100)\")\nleverageBuffer = option(default=0.5, type = range, min = -1, max = 2, step = 0.01, description = \"Buffer added to liquidation distance (% based). Higher values push zones farther.\")\noriginMode = option(default=\"highLow\", type = list, options = [\"ohlc4\", \"close\", \"highLow\", \"reversedHighLow\"], description = \"Reference price used for calculating liquidation zones.\")\nthreshold = option(default=2, type = range, min = 0, max = 200, log = true, description = \"Minimum strength required to render a cell on the chart.\")\nfadeAmount = option(default=0, type = range, min = 0, max = 0.1, step = 0.001, description = \"Amount of strength to fade per bar for old cells (set 0 to disable).\")\nmaxDistance = option(default=0, type = range, min = 0, max = 100, log = true, step = 0.1, description = \"Max % distance from priceRef close to draw a cell (0 = no limit).\")\nfadeStart = option(default=100, type = range, min = 0, max = 200, step = 1, description = \"Delay in bars before fading starts to apply to a cell.\")\nautoScale = option(default=0.19, type = range, min = 0, max = 2, step = 0.01, description = \"Grid cell size = ATR × this factor. Adjust for chart scaling.\")\nautoScaleLength = option(default=200, type = range, min = 1, max = 200, step = 1, description = \"Number of bars used to compute ATR for auto-scaling grid.\")\nautoRescale = option(default=0, type = range, min = 0, max = 1000, log = true, description = \"Auto-refresh cell grid every N bars (0 = disable auto-rescale).\")\nresampleDecay = option(default=0.5, type = range, min = 0, max = 1, step = 0.01, description = \"Softens resampling when grid auto-rescales. 0 = even spread, 1 = hard edge.\")\nfixedScale = option(default=\"\", type = text, placeholder = \"empty = ATR\", description = \"Manual fixed cell size. Leave empty to use ATR-based auto scale.\")\nvolLength = option(default=1, type = range, min = 1, max = 200, step = 1, description = \"Length for average buy/sell volume ratio smoothing.\")\nstrength = option(default=0.5, type = range, min = 0, max = 10, step = 0.001, log = true, description = \"Amplifies visual weight of stronger zones (scaling multiplier).\")\nquote = option(default=null, type = list, options = [null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"], rebuild = true, description = \"Select quote asset to fetch liquidity data from specific pairs.\")\nexchange = option(default=null, type = exchange, rebuild = true, description = \"Select exchange to fetch data from (if multiple supported).\")\ntype = option(default=null, type = list, options = [null, \"spot\", \"perp\"], rebuild = true, description = \"Type of market to use (spot or perpetual).\")\ntheme = option(default='dark', type = list, options = [\"dark\", \"light\", \"custom\"], description = \"Select heatmap color theme.\")\ncolor1 = option(default=rgba(66, 3, 81, 0), type = color, description = \"Custom color - weakest cell\")\ncolor2 = option(default=rgb(63, 56, 113), type = color, description = \"Custom color - weak cell\")\ncolor3 = option(default=rgb(38, 130, 140), type = color, description = \"Custom color - medium cell\")\ncolor4 = option(default=rgb(76, 152, 134), type = color, description = \"Custom color - strong cell\")\ncolor5 = option(default=rgb(240, 218, 24), type = color, description = \"Custom color - strongest cell\")\nuseHK = option(default=false, type = checkbox, description = \"Use Heikin-Ashi bars for source price instead of standard OHLC.\")\nuseLog = option(default=false, type = checkbox, description = \"Apply logarithmic transform to volume ratios (helps normalization).\")\ndrawInfinite = option(default=true, type = checkbox, description = \"Extend zone lines beyond the current viewport.\")\n\nif (!liquidityAtPrices) {\n  // check if liquidityAtPrices isn't defined = initial run of the script\n  lastIndex = null\n  freeSlots = []\n  usedSlots = []\n  boundaries = {}\n  liquidityAtPrices = {}\n  indexOfPrices = {}\n  resistances = []\n  totalResistances = 0\n  supports = []\n  totalSupports = 0\n  pendingRedraws = []\n  var shortLeverage = options.leverages.toString().split(/[|,]/).map(a => +a)\n  var longLeverage = shortLeverage.map(a => -a)\n  resolvedLeverages = shortLeverage.concat(longLeverage)\n  steps = null\n  stepsIndex = null\n\n  if (theme === 'dark') {\n    colors = [\n      'rgba(66,3,81,0)',\n      'rgb(63,56,113)',\n      'rgb(38,130,140)',\n      'rgb(76,152,134)',\n      'rgb(240,218,24)',\n    ]\n  } else if (theme === 'light') {\n    colors = [\n      'rgba(42,0,117,0)',\n      'rgb(148,196,236)',\n      'rgb(255,230,163)',\n      'rgb(255,181,112)',\n      'rgb(255,107,107)',\n    ]\n  } else {\n    colors = [\n      color1,\n      color2,\n      color3,\n      color4,\n      color5,\n    ]\n  }\n\n  for (var i = 0; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    // register each available series as a slot \n    freeSlots.push({\n      index: i,\n      redrawAt: 0\n    })\n\n    // boundaries: { [cellId: string]: *bar index* }\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n\n\n// process only on new candle\nif (bar.length === lastIndex) {\n  return\n}\n\n// get source data\nvar customSrc = source(quote = quote, type = type, exchange = exchange)\n\n// get ohlc, var makes it a ephemere, not stored throuhout multiple executions\nvar price = useHK ? avg_heikinashi(customSrc) : avg_ohlc_with_gaps(customSrc)\n\n// register as internal variable (without var) makes it persistent, and allow to use variable history ex priceRef[1]\npriceRef = price\n\n// grid size\nif (fixedScale) {\n  // absolute\n  steps = fixedScale\n} else {\n  // calculate avg of largest price range of candles\n  var priceRange = price.high - price.low\n  var atr = rma(priceRange, autoScaleLength);\n  if (bar.length < autoScaleLength) {\n    // not enough candles to determine avg price range of candle\n    return\n  }\n\n  if (!steps || (autoRescale && bar.length > stepsIndex + autoRescale)) {\n    // calculate current grid cell size\n    var currentTF = bar.timeframe\n    steps = atr * autoScale\n\n    if (stepsIndex && autoRescale) {\n      var newLiquidityAtPrices = {};\n      var newIndexOfPrices = {};\n      var newResistances = [];\n      var newSupports = [];\n      pendingRedraws = []\n\n      // transport current grid data to the new cell size\n      Object.keys(liquidityAtPrices).forEach(price => {\n        var oldCell = liquidityAtPrices[price];\n        var floatPrice = +price;\n\n        var floorPrice = Math.floor(floatPrice / steps) * steps;\n        var ceilPrice = Math.ceil(floatPrice / steps) * steps;\n        var ratio = (floatPrice - floorPrice) / steps; // 0..1\n        var floorWeightRaw = 1 - ratio;\n        var ceilWeightRaw = ratio;\n\n        // Optional: Soften decay curve\n        var floorWeight = Math.pow(floorWeightRaw, resampleDecay);\n        var ceilWeight = Math.pow(ceilWeightRaw, resampleDecay);\n\n        // Optional: Normalize to keep sum of weights ≈ 1\n        var weightSum = floorWeight + ceilWeight;\n        floorWeight /= weightSum;\n        ceilWeight /= weightSum;\n\n\n        // Spread to floor cell\n        if (!newLiquidityAtPrices[floorPrice]) {\n          newLiquidityAtPrices[floorPrice] = {\n            count: 0,\n            strength: 0,\n            top: floorPrice + steps / 2,\n            bottom: floorPrice - steps / 2\n          };\n          newIndexOfPrices[floorPrice] = [];\n        }\n        newLiquidityAtPrices[floorPrice].strength += oldCell.strength * floorWeight;\n        newLiquidityAtPrices[floorPrice].count += oldCell.count * floorWeight;\n        newIndexOfPrices[floorPrice].push(indexOfPrices[price]);\n\n        // Spread to ceil cell (only if different)\n        if (ceilPrice !== floorPrice) {\n          if (!newLiquidityAtPrices[ceilPrice]) {\n            newLiquidityAtPrices[ceilPrice] = {\n              count: 0,\n              strength: 0,\n              top: ceilPrice + steps / 2,\n              bottom: ceilPrice - steps / 2\n            };\n            newIndexOfPrices[ceilPrice] = [];\n          }\n          newLiquidityAtPrices[ceilPrice].strength += oldCell.strength * ceilWeight;\n          newLiquidityAtPrices[ceilPrice].count += oldCell.count * ceilWeight;\n          newIndexOfPrices[ceilPrice].push(indexOfPrices[price]);\n        }\n\n        if (oldCell.id) {\n          boundaries[oldCell.id] = bar.length + 1;\n        }\n      });\n\n\n      // Calculate new index of prices as the average of merged cells\n      Object.keys(newIndexOfPrices).forEach(price => {\n        const averageIndex = newIndexOfPrices[price].reduce((acc, cur, _, arr) => acc + cur / arr.length, 0);\n        newIndexOfPrices[price] = Math.round(averageIndex);\n        if (price > priceRef[1].close) {\n          newResistances.push(price);\n        } else {\n          newSupports.push(price);\n        }\n\n        if (newLiquidityAtPrices[price].strength > threshold && (!maxDistance || Math.abs(price - priceRef[1].close) / priceRef[1].close * 100 < maxDistance)) {\n          pendingRedraws.push(price);\n        }\n      });\n\n      // Update global variables\n      liquidityAtPrices = newLiquidityAtPrices;\n      indexOfPrices = newIndexOfPrices;\n      resistances = newResistances.sort((a, b) => a - b); // Ensure these are sorted\n      supports = newSupports.sort((a, b) => b - a)\n      pendingRedraws = pendingRedraws.sort((a, b) => (a - priceRef[1].close) - (b - priceRef[1].close))\n    }\n\n    stepsIndex = bar.length\n  }\n}\n\nbuyVolume = source(vbuy, quote = quote, type = type, exchange = exchange)\nsellVolume = source(vsell, quote = quote, type = type, exchange = exchange)\nvol = buyVolume + sellVolume\n\n// since we only run this indi once per bar (for performance)\n// only analyze volume data of the previous bar (vol[1], buyVolume[1], sellVolume[1])\nconst avgBuyVolume = sma(buyVolume[1] || 0, volLength) || 0.0001;\nconst avgSellVolume = sma(sellVolume[1] || 0, volLength) || 0.0001;\n\nvar buyRatio = (buyVolume[1] || 0) / avgBuyVolume;\nvar sellRatio = (sellVolume[1] || 0) / avgSellVolume;\nif (useLog) {\n  buyRatio = Math.log(buyRatio + 1)\n  sellRatio = Math.log(sellRatio + 1)\n}\nvar dirtyResistances = false\nvar dirtySupports = false\n\nfor (let i = 0; i < resolvedLeverages.length; i++) {\n  var lev = (resolvedLeverages)[i]\n  var isResistance = lev > 0\n  var buffer = leverageBuffer / 100  // always positive\n\n  if (originMode === \"ohlc4\") {\n    src = (priceRef[1].open + priceRef[1].high + priceRef[1].low + priceRef[1].close) / 4\n  } else if (originMode === \"close\") {\n    src = priceRef[1].close\n  } else if (originMode === \"highLow\") {\n    src = isResistance ? priceRef[1].high : priceRef[1].low\n  } else if (originMode === \"reversedHighLow\") {\n    src = isResistance ? priceRef[1].low : priceRef[1].high\n  }\n\n  var levAbs = Math.abs(lev)\n  var levDistance = 1 / levAbs\n\n  var mm = (buffer + 0.01 / Math.abs(lev))\n  var offset = levDistance + mm;\n\n  var lp = src * (1 + (isResistance ? offset : -offset))\n\n\n  // rounded lp median (the cell id)\n  var slp = (isResistance ? Math.floor(lp / steps) : Math.ceil(lp / steps)) * steps\n\n  if (!liquidityAtPrices[slp]) {\n    // register cell\n    var top = slp + steps / 2\n    var bottom = slp - steps / 2\n    liquidityAtPrices[slp] = {\n      strength: 0,\n      index: bar.length,\n      top: top,\n      bottom: bottom,\n      count: 1\n    }\n\n    if (isResistance) {\n      resistances.push(slp)\n      dirtyResistances = true\n    } else {\n      supports.push(slp)\n      dirtySupports = true\n    }\n  }\n\n  // update cell\n  var currentIncrease = isResistance ? sellRatio : buyRatio\n  liquidityAtPrices[slp].strength += currentIncrease\n  liquidityAtPrices[slp].count += 1\n  if (isResistance) {\n    totalResistances += currentIncrease\n  } else {\n    totalSupports += currentIncrease\n  }\n\n  if (!indexOfPrices[slp]) {\n    indexOfPrices[slp] = bar.length\n  }\n  if (liquidityAtPrices[slp].strength > threshold && (!maxDistance || Math.abs(slp - priceRef[1].close) / priceRef[1].close * 100 < maxDistance)) {\n    if (pendingRedraws.indexOf(slp) === -1) {\n      pendingRedraws.unshift(slp)\n    }\n  }\n}\ndirtyResistances && resistances.sort((a, b) => a - b)\ndirtySupports && supports.sort((a, b) => b - a)\n\nif (pendingRedraws.length) {\n\n  // round of used slot(s)\n  var slotsToRelease = []\n  for (var i = 0; i < pendingRedraws.length; i++) {\n    var cell = liquidityAtPrices[pendingRedraws[i]]\n\n    if (!cell) {\n      pendingRedraws.splice(i--, 1)\n      continue\n    }\n\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\n\n    if (slot) {\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\n      usedSlots.push(usedIndex)\n\n      if (cell.id) {\n        boundaries[cell.id] = bar.length - 2\n      }\n\n      cell.id = Math.random().toString()\n      cell.lastStrength = cell.strength\n\n      var ratio = Math.max(0.01, Math.min(1, cell.strength * cell.count * (options.strength / 100)))\n      var color = interpolate(ratio, ...(colors))\n\n      bar.series[series[usedIndex].id] = {\n        id: cell.id,\n        time: time - bar.timeframe,\n        lowerValue: cell.top,\n        higherValue: cell.bottom,\n        extendRight: true,\n        color: color\n      }\n\n      pendingRedraws.splice(i--, 1)\n      slotsToRelease.push(usedIndex)\n    } else {\n      break;\n    }\n  }\n  for (let i = 0; i < slotsToRelease.length; i++) {\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\n\n    freeSlots.push({\n      index: plotIndexToFree,\n      redrawAt: bar.length + 1\n\n    })\n  }\n}\n\nfor (let i = 0; i < supports.length; i++) {\n  var slp = supports[i]\n\n  if (\n    price.low <= slp || liquidityAtPrices[slp].strength === 0\n  ) {\n    if (price.low <= slp) {\n      delete indexOfPrices[slp]\n    }\n\n    var pendingRedrawIndex = pendingRedraws.indexOf(slp)\n\n    if (pendingRedrawIndex !== -1) {\n      pendingRedraws.splice(pendingRedrawIndex, 1)\n    }\n\n    if (liquidityAtPrices[slp].id) {\n      boundaries[liquidityAtPrices[slp].id] = bar.length - 2\n    }\n\n    totalSupports -= liquidityAtPrices[slp].strength\n    delete liquidityAtPrices[slp]\n    supports.splice(i--, 1)\n  } else {\n    if (fadeAmount) {\n      if (bar.length > indexOfPrices[slp] + fadeStart) {\n        var currentFade = Math.min(fadeAmount, liquidityAtPrices[slp].strength)\n        liquidityAtPrices[slp].strength -= currentFade\n        totalSupports -= currentFade\n        var pendingRedrawIndex = pendingRedraws.indexOf(slp)\n        if (liquidityAtPrices[slp].strength > threshold && (!maxDistance || Math.abs(slp - priceRef[1].close) / priceRef[1].close * 100 < maxDistance)) {\n          if (pendingRedrawIndex === -1) {\n            pendingRedraws.push(slp)\n          }\n        } else if (liquidityAtPrices[slp].id) {\n          boundaries[liquidityAtPrices[slp].id] = bar.length - 2\n          delete liquidityAtPrices[slp].id\n          if (pendingRedrawIndex !== -1) {\n            pendingRedraws.splice(pendingRedrawIndex, 1)\n          }\n        }\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nfor (let i = 0; i < resistances.length; i++) {\n  var slp = resistances[i]\n\n  if (\n    price.high >= slp || liquidityAtPrices[slp].strength === 0\n  ) {\n    if (price.high >= slp) {\n      delete indexOfPrices[slp]\n    }\n\n    var pendingRedrawIndex = pendingRedraws.indexOf(slp)\n\n    if (pendingRedrawIndex !== -1) {\n      pendingRedraws.splice(pendingRedrawIndex, 1)\n    }\n\n    if (liquidityAtPrices[slp].id) {\n      boundaries[liquidityAtPrices[slp].id] = bar.length - 1\n    }\n\n    totalResistances -= liquidityAtPrices[slp].strength\n    delete liquidityAtPrices[slp]\n    resistances.splice(i--, 1)\n  } else {\n    if (fadeAmount) {\n      if (bar.length > indexOfPrices[slp] + fadeStart) {\n        var currentFade = Math.min(fadeAmount, liquidityAtPrices[slp].strength)\n        liquidityAtPrices[slp].strength -= currentFade\n        totalResistances -= currentFade\n        var pendingRedrawIndex = pendingRedraws.indexOf(slp)\n        if (liquidityAtPrices[slp].strength > threshold && (!maxDistance || Math.abs(slp - priceRef[1].close) / priceRef[1].close * 100 < maxDistance)) {\n          if (pendingRedrawIndex === -1) {\n            pendingRedraws.push(slp)\n          }\n        } else if (liquidityAtPrices[slp].id) {\n          boundaries[liquidityAtPrices[slp].id] = bar.length - 2\n          delete liquidityAtPrices[slp].id\n          if (pendingRedrawIndex !== -1) {\n            pendingRedraws.splice(pendingRedrawIndex, 1)\n          }\n        }\n      }\n    } else {\n      break;\n    }\n  }\n}\n\n// set reference to bar index : avoid process next tick\nlastIndex = bar.length\n\n// define slots, 20 is reasonable amount\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)\nbrokenarea(infinite = drawInfinite)",
    "createdAt": 1704326463912,
    "updatedAt": 1742168570467,
    "displayName": "Liquidation Heatmap",
    "description": "Visualizes potential liquidation levels\n\n",
    "enabled": false,
    "author": "aggr",
    "pr": "https://github.com/Tucsky/aggr-lib/pull/42"
  }
}