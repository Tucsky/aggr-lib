{
  "type": "indicators",
  "name": "indicators:Liquidation Heatmap",
  "data": {
    "id": "liquidation-heatmap",
    "name": "Liquidation Heatmap",
    "options": {
      "priceScaleId": "right",
      "leverages": "5|25|100",
      "threshold": 0,
      "fadeOut": 0,
      "stepScale": 0.4,
      "stepValue": "",
      "strength": 0.25,
      "quote": 0,
      "exchange": 0,
      "type": "perp",
      "src": "high/low",
      "volLength": 20,
      "atrLength": 20,
      "useHK": true,
      "useLog": true,
      "strokeWidth": 0,
      "drawInfinite": false,
      "visible": true
    },
    "script": "leverages = option(default=25|50|100,type=text)\nthreshold = option(default=0,type=range,min=0,max=220,log=true)\nfadeOut = option(default=0,type=range,min=0,max=1,log=true,step=0.001)\nstepScale = option(default=0.5,type=range,min=0,max=2,step=0.01)\nstepValue = option(default=\"\",type=text,placeholder=\"empty = ATR\")\nstrength = option(default=0.25,type=range,min=0,max=10,step=0.01,log=true)\nquote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\nexchange = option(default=null,type=exchange,rebuild=true)\ntype = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\nsrc = option(default=\"high/low\",type=list,options=[\"open\", \"high\", \"low\", \"close\",\"hl2\",\"ohl3\",\"ohlc4\",\"hlcc4\",\"high/low\",\"low/high\"])\ncolor0 = option(default=rgba(0,0,0,0),type=color)\ncolor1 = option(default=rgb(63,16,87),type=color)\ncolor2 = option(default=rgb(76,152,134),type=color)\ncolor3 = option(default=rgb(240,218,24),type=color)\nvolLength = option(default=20,type=range,min=1,max=200, step=1)\natrLength = option(default=20,type=range,min=1,max=200, step=1)\nuseHK = option(default=true,type=checkbox,description=\"Use heikinashi as source\")\nuseLog = option(default=true,type=checkbox)\ndrawInfinite = option(default=false,type=checkbox,description=\"Draw cells even if started are out of the view\")\n\nif (!liquidityAtPrices) {\n  // init\n\n  lastIndex = null\n  freeSlots = []\n  usedSlots = []\n  boundaries = {}\n  liquidityAtPrices = {}\n  resistances = []\n  supports = []\n  pendingRedraws = []\n  var shortLeverage = options.leverages.toString().split(/[|,]/).map(a => +a)\n  var longLeverage = shortLeverage.map(a => -a)\n  resolvedLeverages = shortLeverage.concat(longLeverage)\n  steps = null\n\n  for (var i = 0; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    // register each available series as a slot \n    freeSlots.push({\n    index: i,\n    redrawAt: 0\n    })\n\n    // bind boundaries reference\n    // boundaries: { [cellId: string]: *bar index* }\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n\n\n// process only on new candle\nif (bar.length === lastIndex) {\n  return\n}\n\nvar customSrc = source(quote=quote,type=type,exchange=exchange)\nvar price = useHK ? avg_heikinashi(customSrc) : avg_ohlc_with_gaps(customSrc)\n\npriceRef = price\n\n// grid size\nif (stepValue) {\n  // absolute\n  steps = stepValue\n} else {\n  // calculated with atr\n  var hl = price.high - price.low\n  var hc = Math.abs(price.high - priceRef[1].close)\n  var lc = Math.abs(price.low - priceRef[1].close)\n  var atr = sma(Math.max(hl, hc, lc), atrLength)\n\n  if (bar.length < atrLength) {\n    return\n  }\n\n  if (!steps) {\n    steps = atr * stepScale\n  }\n}\n\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\nvol = buyVolume + sellVolume\n\n// since we only run this indi once per bar (for performance)\n// only analyze volume data of the previous bar (vol[1], buyVolume[1], sellVolume[1])\nconst avgBuyVolume = sma(buyVolume[1] || 0, volLength) || 0.0001;\nconst avgSellVolume = sma(sellVolume[1] || 0, volLength) || 0.0001;\n\nvar buyRatio = (buyVolume[1] || 0) / avgBuyVolume;\nvar sellRatio = (sellVolume[1] || 0) / avgSellVolume;\nif (useLog) {\n  buyRatio = Math.log(buyRatio + 1)\n  sellRatio = Math.log(sellRatio + 1)\n}\n\n// custom src\nvar resolvedSrc  = priceRef[1][options.src]\nif (resolvedSrc === undefined) {\n  if (options.src === 'hl2') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low) / 2\n  } else if (options.src === 'ohl3') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low) / 3\n  } else if (options.src === 'ohlc4') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low + priceRef[1].close) / 4\n  } else if (options.src === 'hlcc4') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low + priceRef[1].close + priceRef[1].close) / 4\n  }\n}\n\nfor (let i = 0; i < resolvedLeverages.length; i++) {\n  var lev = (resolvedLeverages)[i]\n\n  if (options.src === 'high/low') {\n    resolvedSrc = lev > 0 ? priceRef[1].high : priceRef[1].low\n  } else if (options.src === 'low/high') {\n    resolvedSrc = lev > 0 ? priceRef[1].low : priceRef[1].high\n  }\n\n  // liquidation price (from resolvedSrc + % to leverages[i]) \n  var lp = (resolvedSrc + resolvedSrc * (100 / lev / 100))\n  \n  // rounded lp median (the cell id)\n  var slp = Math.ceil(lp / steps) * steps\n  \n  if (!liquidityAtPrices[slp]) {\n    // register cell\n    var top = slp + steps / 2\n    var bottom = slp - steps / 2\n    liquidityAtPrices[slp] = {\n      strength: 0,\n      count: 0,\n      top: top,\n      bottom: bottom\n    }\n    \n    if (lev > 0) {\n        resistances.push(slp)\n        resistances.sort((a, b) => a - b)\n    } else {\n        supports.push(slp)\n        supports.sort((a, b) => b - a)\n    }\n  }\n  \n  // update cell\n  liquidityAtPrices[slp].count++\n  liquidityAtPrices[slp].strength += lev > 0 ? sellRatio : buyRatio\n  \n  var ratio = Math.min(1, liquidityAtPrices[slp].strength * liquidityAtPrices[slp].count * (options.strength / 100))\n\n  if (ratio < 0.001) {\n    continue\n  }\n  \n  liquidityAtPrices[slp].color = interpolate(ratio, color0, color1, color2, color3)\n\n  if (liquidityAtPrices[slp].strength > options.threshold) {\n    if (pendingRedraws.indexOf(slp) === -1) {\n      pendingRedraws.push(slp)\n    }\n  }\n}\n\nif (pendingRedraws.length) {\n\n  // round of used slot(s)\n  var slotsToRelease = []\n  for (var i = 0; i < pendingRedraws.length; i++) {\n    var cell = liquidityAtPrices[pendingRedraws[i]]\n    if (!cell) {\n      pendingRedraws.splice(i--, 1)\n      continue\n    }\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\n\n    if (slot) {\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\n      usedSlots.push(usedIndex)\n\n      if (cell.id) {\n        boundaries[cell.id] = bar.length - 1\n      }\n      \n      cell.id = Math.random().toString()\n      renderer.indicators[indicatorId].series[usedIndex] ={\n        id: cell.id,\n        time: time,\n        lowerValue: cell.top,\n        higherValue: cell.bottom,\n        extendRight: true,\n        color: cell.color\n      }\n\n      pendingRedraws.splice(i--, 1)\n      slotsToRelease.push(usedIndex)\n    }\n  }\n  for (let i = 0; i < slotsToRelease.length; i++) {\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\n    \n    freeSlots.push({\n      index: plotIndexToFree,\n      redrawAt: bar.length + 1\n    })\n  }\n}\n\nfor (let i = 0; i < supports.length; i++) {\n  if (\n   price.low <= supports[i] || liquidityAtPrices[supports[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[supports[i]].id] = bar.length - 1\n\n    delete liquidityAtPrices[supports[i]]\n    supports.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[supports[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\nfor (let i = 0; i < resistances.length; i++) {\n  if (\n   price.high >= resistances[i] || liquidityAtPrices[resistances[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[resistances[i]].id] = bar.length - 1\n    delete liquidityAtPrices[resistances[i]]\n    resistances.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[resistances[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\n// set reference to bar index : avoid process next tick\nlastIndex = bar.length\n\n// define available series\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)",
    "createdAt": 1703543399433,
    "updatedAt": 1708674124907,
    "displayName": "Liquidation Heatmap",
    "description": "Visualizes potential liquidation levels",
    "author": "aggr"
  }
}