{
  "type": "indicator",
  "name": "indicators:Liquidation Heatmap",
  "data": {
    "script": "leverages = option(default=5|20|100,type=text)\nthreshold = option(default=5,type=range,min=0,max=200,log=true)\nfadeAmount = option(default=0.02,type=range,min=0,max=2,step=0.01)\nfadeStart = option(default=100,type=range,min=0,max=200,step=1)\nautoScale = option(default=0.39,type=range,min=0,max=2,step=0.01)\nautoScaleLength = option(default=200,type=range,min=1,max=200,step=1)\nautoRescale = option(default=0,type=range,min=0,max=1000,log=true)\nfixedScale = option(default=\"\",type=text,placeholder=\"empty = ATR\")\nstrength = option(default=0.25,type=range,min=0,max=10,step=0.001,log=true)\ndemultiplier = option(default=1,type=range,min=0,max=10,step=0.001,log=true)\nquote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\nexchange = option(default=null,type=exchange,rebuild=true)\ntype = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\ncolor0 = option(default=rgba(42,0,117,0),type=color)\ncolor1 = option(default=rgb(63,16,87),type=color)\ncolor2 = option(default=rgb(76,152,134),type=color)\ncolor3 = option(default=rgb(240,218,24),type=color)\nvolLength = option(default=1,type=range,min=1,max=200, step=1)\nuseHK = option(default=false,type=checkbox,description=\"Use heikinashi as source\")\nuseLog = option(default=false,type=checkbox)\nshowChanges = option(type=checkbox)\ndrawInfinite = option(default=true,type=checkbox,description=\"Draw beyond viewport\")\nuseLegacyLp  = option(default=false,type=checkbox)\nif (!liquidityAtPrices) {\n  // check if liquidityAtPrices isn't defined = initial run of the script\n\n  lastIndex = null\n  freeSlots = []\n  usedSlots = []\n  boundaries = {}\n  liquidityAtPrices = {}\n  indexOfPrices = {}\n  resistances = []\n  totalResistances = 0\n  supports = []\n  totalSupports = 0\n  pendingRedraws = []\n  var shortLeverage = options.leverages.toString().split(/[|,]/).map(a => +a)\n  var longLeverage = shortLeverage.map(a => -a)\n  resolvedLeverages = shortLeverage.concat(longLeverage)\n  steps = null\n  stepsIndex = null\n\n  for (var i = 0; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    // register each available series as a slot \n    freeSlots.push({\n    index: i,\n    redrawAt: 0\n    })\n\n    // boundaries: { [cellId: string]: *bar index* }\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n\n\n// process only on new candle\nif (bar.length === lastIndex) {\n  return\n}\n\n// get source data\nvar customSrc = source(quote=quote,type=type,exchange=exchange)\n\n// get ohlc, var makes it a ephemere, not stored throuhout multiple executions\nvar price = useHK ? avg_heikinashi(customSrc) : avg_ohlc_with_gaps(customSrc)\n\n// register as internal variable (without var) makes it persistent, and allow to use variable history ex priceRef[1]\npriceRef = price\n\n// grid size\nif (fixedScale) {\n  // absolute\n  steps = fixedScale\n} else {\n  // calculate avg of largest price range of candles\n  var priceRange = price.high - price.low\n\n  var atr = rma(priceRange, autoScaleLength);\n\n  if (bar.length < autoScaleLength) {\n    // not enough candles to determine avg price range of candle\n    return\n  }\n  \n  if (!steps || (autoRescale && bar.length > stepsIndex + autoRescale)) {\n    // calculate current grid cell size\n    steps = atr * autoScale\n\n    if (stepsIndex && autoRescale) {\n      var newLiquidityAtPrices = {};\n      var newIndexOfPrices = {};\n      var newResistances = [];\n      var newSupports = [];\n      pendingRedraws = []\n\n      // transport current grid data to the new cell size\n      Object.keys(liquidityAtPrices).forEach(price => {\n        var newPrice = Math.round(price / steps) * steps;\n        var oldCell = liquidityAtPrices[price];\n    \n        if (!newLiquidityAtPrices[newPrice]) {\n          newLiquidityAtPrices[newPrice] = { count: 0, strength: 0, top: newPrice + steps / 2, bottom: newPrice - steps / 2 };\n          newIndexOfPrices[newPrice] = [];\n        }\n    \n        // Aggregate strengths and index of prices\n        newLiquidityAtPrices[newPrice].strength += oldCell.strength;\n        newLiquidityAtPrices[newPrice].count += oldCell.count;\n        newIndexOfPrices[newPrice].push(indexOfPrices[price]);\n\n        if (oldCell.id) {\n          boundaries[oldCell.id] = bar.length;\n        }\n      });\n    \n      // Calculate new index of prices as the average of merged cells\n      Object.keys(newIndexOfPrices).forEach(price => {\n        const averageIndex = newIndexOfPrices[price].reduce((acc, cur, _, arr) => acc + cur / arr.length, 0);\n        newIndexOfPrices[price] = Math.round(averageIndex);\n        if (price > priceRef[1].close) {\n          newResistances.push(price);\n        } else {\n          newSupports.push(price);\n        }\n      \n        if (newLiquidityAtPrices[price].strength > threshold) {\n          pendingRedraws.push(price);\n        }\n      });\n    \n      // Update global variables\n      liquidityAtPrices = newLiquidityAtPrices;\n      indexOfPrices = newIndexOfPrices;\n      resistances = newResistances.sort((a, b) => a - b); // Ensure these are sorted\n      supports = newSupports.sort((a, b) => b - a)\n      pendingRedraws = pendingRedraws.sort((a, b) => (a - priceRef[1].close) - (b - priceRef[1].close))\n    }\n    \n    stepsIndex = bar.length\n  }\n}\n\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\nvol = buyVolume + sellVolume\n\n// since we only run this indi once per bar (for performance)\n// only analyze volume data of the previous bar (vol[1], buyVolume[1], sellVolume[1])\nconst avgBuyVolume = sma(buyVolume[1] || 0, volLength) || 0.0001;\nconst avgSellVolume = sma(sellVolume[1] || 0, volLength) || 0.0001;\n\nvar buyRatio = (buyVolume[1] || 0) / avgBuyVolume;\nvar sellRatio = (sellVolume[1] || 0) / avgSellVolume;\nif (useLog) {\n  buyRatio = Math.log(buyRatio + 1)\n  sellRatio = Math.log(sellRatio + 1)\n}\nvar dirtyResistances = false\nvar dirtySupports = false\n\nfor (let i = 0; i < resolvedLeverages.length; i++) {\n  var lev = (resolvedLeverages)[i]\n\n  var isResistance = lev > 0\n\n  var src = isResistance ? priceRef[1].high : priceRef[1].low\n\n  // liquidation price (from resolvedSrc + % to leverages[i]) \n  if (useLegacyLp) {\n    if (isResistance) {\n    var lp = src * (1 + (1 / Math.abs(lev)) + 0.005);\n    } else {\n    var lp = src * (1 - (1 / Math.abs(lev)) + 0.005);\n    }\n  } else {\n    var lp =(src + src * (100 / lev / 100))\n  }\n\n  // rounded lp median (the cell id)\n  var slp = (isResistance ? Math.floor(lp / steps) : Math.ceil(lp / steps)) * steps\n  \n  if (!liquidityAtPrices[slp]) {\n    // register cell\n    var top = slp + steps / 2\n    var bottom = slp - steps / 2\n    liquidityAtPrices[slp] = {\n      strength: 0,\n      index: bar.length,\n      top: top,\n      bottom: bottom,\n      count: 1\n    }\n    \n    if (isResistance) {\n      resistances.push(slp)\n      dirtyResistances = true\n    } else {\n      supports.push(slp)\n      dirtySupports = true\n    }\n  }\n  \n  // update cell\n  var currentIncrease = isResistance ? sellRatio : buyRatio\n  liquidityAtPrices[slp].strength += currentIncrease\n  liquidityAtPrices[slp].count += demultiplier\n  if (isResistance) {\n    totalResistances += currentIncrease\n  } else {\n    totalSupports += currentIncrease\n  }\n  \n  if (!indexOfPrices[slp]) {\n    indexOfPrices[slp] = bar.length\n  }\n\n  if (liquidityAtPrices[slp].strength > threshold) {\n    if (pendingRedraws.indexOf(slp) === -1) {\n      pendingRedraws.unshift(slp)\n    }\n  }\n}\ndirtyResistances && resistances.sort((a, b) => a - b)\ndirtySupports && supports.sort((a, b) => b - a)\n\nif (pendingRedraws.length) {\n\n  // round of used slot(s)\n  var slotsToRelease = []\n  for (var i = 0; i < pendingRedraws.length; i++) {\n    var cell = liquidityAtPrices[pendingRedraws[i]]\n\n    if (!cell) {\n      pendingRedraws.splice(i--, 1)\n      continue\n    }\n    \n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\n\n    if (slot) {\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\n      usedSlots.push(usedIndex)\n\n      if (cell.id) {\n        boundaries[cell.id] = bar.length - 2\n      }\n      \n      cell.id = Math.random().toString()\n      cell.lastStrength = cell.strength\n      \n      var ratio = Math.max(0.01, Math.min(1, cell.strength * cell.count * (options.strength / 100)))\n      var color = interpolate(ratio, color0, color1, color2, color3)\n      \n      bar.series[series[usedIndex].id] ={\n        id: cell.id,\n        time: time - bar.timeframe,\n        lowerValue: cell.top,\n        higherValue: cell.bottom,\n        extendRight: true,\n        color: color\n      }\n\n      pendingRedraws.splice(i--, 1)\n      slotsToRelease.push(usedIndex)\n    } else {\n      break;\n    }\n  }\n  for (let i = 0; i < slotsToRelease.length; i++) {\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\n    \n    freeSlots.push({\n      index: plotIndexToFree,\n      redrawAt: bar.length +1\n      \n    })\n  }\n}\n\nfor (let i = 0; i < supports.length; i++) {\n  var slp = supports[i]\n\n  if (\n   price.low <= slp || liquidityAtPrices[slp].strength === 0\n  ) {\n    if (price.low <= slp) {\n      delete indexOfPrices[slp]\n    }\n\n    var pendingRedrawIndex = pendingRedraws.indexOf(slp)\n\n    if (pendingRedrawIndex !== -1) {\n      pendingRedraws.splice(pendingRedrawIndex, 1)\n    }\n\n    if (liquidityAtPrices[slp].id) {\n      boundaries[liquidityAtPrices[slp].id] = bar.length - 2\n    }\n\n    totalSupports -= liquidityAtPrices[slp].strength\n    delete liquidityAtPrices[slp]\n    supports.splice(i--, 1)\n  } else {\n    if (fadeAmount) {\n      if (bar.length > indexOfPrices[slp] + fadeStart) {\n        var currentFade = Math.min(fadeAmount, liquidityAtPrices[slp].strength)\n        liquidityAtPrices[slp].strength -= currentFade\n        totalSupports -= currentFade\n        var pendingRedrawIndex = pendingRedraws.indexOf(slp)\n        if (liquidityAtPrices[slp].strength > threshold) {\n          if (pendingRedrawIndex === -1) {\n            pendingRedraws.push(slp)\n          }\n        } else if (liquidityAtPrices[slp].id) {\n          boundaries[liquidityAtPrices[slp].id] = bar.length - 2\n          delete liquidityAtPrices[slp].id\n          if (pendingRedrawIndex !== -1) {\n            pendingRedraws.splice(pendingRedrawIndex, 1)\n          }\n        }\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nfor (let i = 0; i < resistances.length; i++) {\n  var slp = resistances[i]\n\n  if (\n   price.high >= slp || liquidityAtPrices[slp].strength === 0\n  ) {\n    if (price.high >= slp) {\n      delete indexOfPrices[slp]\n    }\n\n    var pendingRedrawIndex = pendingRedraws.indexOf(slp)\n\n    if (pendingRedrawIndex !== -1) {\n      pendingRedraws.splice(pendingRedrawIndex, 1)\n    }\n\n    if (liquidityAtPrices[slp].id) {\n      boundaries[liquidityAtPrices[slp].id] = bar.length - 1\n    }\n\n    totalResistances -= liquidityAtPrices[slp].strength\n    delete liquidityAtPrices[slp]\n    resistances.splice(i--, 1)\n  } else {\n    if (fadeAmount) {\n      if (bar.length > indexOfPrices[slp] + fadeStart) {\n        var currentFade = Math.min(fadeAmount, liquidityAtPrices[slp].strength)\n        liquidityAtPrices[slp].strength -= currentFade\n        totalResistances -= currentFade\n        var pendingRedrawIndex = pendingRedraws.indexOf(slp)\n        if (liquidityAtPrices[slp].strength > threshold) {\n          if (pendingRedrawIndex === -1) {\n            pendingRedraws.push(slp)\n          }\n        } else if (liquidityAtPrices[slp].id) {\n          boundaries[liquidityAtPrices[slp].id] = bar.length - 2\n          delete liquidityAtPrices[slp].id\n          if (pendingRedrawIndex !== -1) {\n            pendingRedraws.splice(pendingRedrawIndex, 1)\n          }\n        }\n      }\n    } else {\n      break;\n    }\n  }\n}\n\n// set reference to bar index : avoid process next tick\nlastIndex = bar.length\n\n// define slots, 20 is reasonable amount\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\nbrokenarea(infinite=drawInfinite)\n\nif (showChanges) {\n  res = totalResistances\n  sup = totalSupports\n  var resChg = totalResistances - totalResistances[1]\n  var supChg = totalSupports - totalSupports[1]\n  histogram(\n    {\n      time: time,\n      value: resChg,\n      color: resChg > 0 ? 'green' : 'red'\n    },\n    priceScaleId=overlay1,\n    scaleMargins={top: 0.01, bottom: 0.95},\n    lastValueVisible=true,\n    title=\"R\"\n  )\n  histogram(\n    {\n      time: time,\n      value: supChg,\n      color: supChg > 0 ? 'green' : 'red'\n    },\n    priceScaleId=overlay2,\n    scaleMargins={top: 0.06, bottom: 0.9},\n    lastValueVisible=true,\n    title=\"S\"\n  )\n}",
    "createdAt": 1707951098767,
    "updatedAt": 1729108628977,
    "displayName": "Liquidation Heatmap",
    "description": "Visualizes potential liquidation levels",
    "enabled": false,
    "author": "aggr",
    "pr": "https://github.com/Tucsky/aggr-lib/pull/33",
    "options": {}
  }
}