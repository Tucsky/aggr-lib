{
  "type": "indicators",
  "name": "indicators:Fibonacci Grid",
  "data": {
    "id": "fibonacci-grid",
    "name": "Fibonacci Grid",
    "options": {
      "priceScaleId": "right",
      "compositeOperation": null,
      "debugDown": false,
      "debugUp": false,
      "drawCount": 2,
      "enableInvalidation": true,
      "enableTarget": true,
      "extendBase": true,
      "invalidateSwing": false,
      "levelMult": 1,
      "levels": "0,1,2,3,5,8,13,21,34,55,89",
      "maxRetracement": 0,
      "originDown": null,
      "originUp": null,
      "originWidth": 1.5,
      "pivotLeft": null,
      "showLabel": false,
      "showUp": true,
      "singleSide": false,
      "strokeWidth": 1.5,
      "targetLevelUp": 89,
      "up": null,
      "useGaps": true,
      "useHeikinAshi": false,
      "useNext": null,
      "useTrailStop": null,
      "upColor": "rgb(0,255,10)",
      "borderDownColor": "rgba(0,0,0,0)",
      "borderUpColor": "rgba(0,0,0,0)",
      "color": "rgba(255,255,255,0.4)",
      "debugColor": "rgba(255,255,255,0.5)",
      "downColor": "rgba(0,0,0,0)",
      "lineColor": "rgb(255,235,59)",
      "originColor": "rgb(255,229,0)",
      "wickDownColor": "rgba(0,0,0,0)",
      "wickUpColor": "rgba(0,0,0,0)",
      "priceLineColor": "rgba(0,0,0,0)",
      "levelMultiplier": 1,
      "levelOffset": "",
      "originUpColor": "rgba(255,235,59,0.5)",
      "scaleMargins": {
        "top": 0.04,
        "bottom": 0.11
      },
      "borderVisible": false,
      "visible": true,
      "lastValueVisible": false,
      "priceLineVisible": false,
      "useCustomSource": true,
      "exchange": "BINANCE",
      "exchangeFilter": "BITFINEX",
      "quoteFilter": "USD",
      "srcExchange": "",
      "srcQuote": "",
      "srcType": "",
      "debug": false
    },
    "script": "// <STARTUP SCRIPT> \r\nif (!pendingMarkers) {\r\n  if (options.debug) {\r\n    console.clear()\r\n  }\r\n  // runs only once\r\n  markers = []\r\n  pendingMarkers = []\r\n  lastIndex = null\r\n  freeSlots = []\r\n  usedSlots = []\r\n  swings = []\r\n  rawLevels = options.levels.toString().split(',').map(a => +a)\r\n  baseLevelIndex = rawLevels.indexOf(0)\r\n  up = {}\r\n  boundaries = {}\r\n  levelMult = options.levelMult.toString().split(',').map(a => +a)\r\n  levels = rawLevels.reduce((acc, level, index, arr) => {\r\n    return levelMult.reduce((acc2, val) => {\r\n      arr[index + 1] && acc2.push(+(level + (arr[index + 1] - level) * val).toFixed(3))\r\n      return acc2\r\n    }, acc)\r\n  }, [rawLevels[0]])\r\n  for (var i = 1; i < series.length; i++) {\r\n    if (series[i].seriesType() !== 'BrokenArea') {\r\n      continue\r\n    }\r\n\r\n    freeSlots.push({\r\n      index: i,\r\n      redrawAt: 0\r\n    })\r\n\r\n    series[i].setExtensionsBoundaries(boundaries)\r\n  }\r\n}\r\n// </STARTUP SCRIPT> \r\n\r\n// <MARKERS.UTILS> \r\nif (pendingMarkers.length) {\r\n  markers = markers.concat(pendingMarkers)\r\n  if (series[0].setMarkers) {\r\n    series[0].setMarkers(markers)\r\n  }\r\n  pendingMarkers = []\r\n}\r\n// </MARKERS.UTILS>\r\n\r\n// process only on new candle\r\nif (bar.length === lastIndex) {\r\n  return\r\n}\r\nspot = options.srcExchange || options.srcType || options.srcQuote ? source(type=options.srcType, exchange=options.srcExchange, quote=options.srcQuote) : bar\r\n\r\nif (!spot) {\r\n  return\r\n}\r\nprice = options.useHeikinAshi ? avg_heikinashi(spot) : options.useGaps ? avg_ohlc_with_gaps(spot) : avg_ohlc(spot)\r\ncandlestick(price, upColor=transparent, downColor=transparent, wickUpColor=transparent, wickDownColor=transparent, showBorders=false) // ghost price for markers\r\n\r\n// constants and working values\r\nopen = price.open\r\nclose = price.close\r\nhigh = price.high\r\nlow = price.low\r\nvar workingClose = close[1]\r\nvar workingOpen = open[1]\r\nvar workingHigh = high[1]\r\nvar workingLow = low[1]\r\nvar workingTime = time\r\nvar swingHigh = workingClose > workingOpen && close <= open ? Math.min(open, workingClose) : null\r\nvar swingLow = workingClose < workingOpen && close >= open ? Math.max(open, workingClose) : null\r\n\r\nif (swingHigh) {\r\n  (options.debug) && pendingMarkers.push({\r\n    time: workingTime,\r\n    position: 'aboveBar',\r\n    color: options.debugColor,\r\n    text: 'SH'\r\n  })\r\n}\r\n\r\nif (swingLow) {\r\n  (options.debug) && pendingMarkers.push({\r\n    time: workingTime,\r\n    position: 'belowBar',\r\n    color: options.debugColor,\r\n    text: 'SL'\r\n  })\r\n}\r\n\r\nif (swingHigh || swingLow) {\r\n  swings.unshift(swingHigh || swingLow)\r\n  if (swings.length > 4) {\r\n    swings.pop()\r\n  }\r\n}\r\n\r\nif (options.showUp) {\r\n  if (up.valid) {\r\n    // up trend origin broken ‚ùå\r\n    if (options.enableInvalidation && (options.invalidateSwing ? swingHigh && swingHigh < up.invalidation : workingClose < up.invalidation)) {\r\n      options.debug && console.log(bar.length, up.id, 'closed below invalidation level ‚ùå', workingClose + '<' + up.invalidation);\r\n      // deactivate trend\r\n      up.valid = false\r\n      if (options.debug) {\r\n        pendingMarkers.push({\r\n          time: workingTime,\r\n          position: 'inBar',\r\n          color: options.debugColor,\r\n          text: '‚ùå' + (options.debug ? up.id : ''),\r\n        })\r\n      }\r\n    }\r\n  \r\n    // up trend target reached üí∞\r\n    if (options.enableTarget && high[1] >= up.target) {\r\n      up.valid = false\r\n      pendingMarkers.push({\r\n        time: time,\r\n        position: 'aboveBar',\r\n        color: options.debugColor,\r\n        text: 'üí∞' + (options.debug ? up.id : '')\r\n      })\r\n    }\r\n  }\r\n\r\n  // in active up trend process\r\n  if (up.active) {\r\n\r\n    // ranges breakout\r\n    if (workingClose > up.levels[up.higherIndex].price) { // move next\r\n      if (options.debug) { console.log(bar.length, up.id, 'up breakout (next)', workingClose + ' > ' + up.levels[up.higherIndex].price) }\r\n\r\n      for (let i = up.levels[up.higherIndex].index + 1; i < levels.length; i++) {\r\n        var higherPriceLevel = up.origin + up.impulse * levels[i]\r\n\r\n        if (workingClose < higherPriceLevel) {\r\n          var change = i - up.levels[up.higherIndex].index // +1\r\n          if (options.debug) { console.log(bar.length, up.id, 'change:', change) }\r\n          if (up.levels[0].index + change < 0 || up.levels[up.levels.length - 1].index + change > levels.length - 1) {\r\n            if (options.debug) { console.log(bar.length, up.id, 'reached levels boundary') }\r\n            break\r\n          }\r\n          up.redrawRequired = true\r\n\r\n          for (var j = 0; j < up.levels.length; j++) {\r\n            up.levels[j].index = up.levels[j].index + change\r\n\r\n\r\n            if (j < change && up.drawings[up.levels[j].price]) {\r\n              // level out of scope\r\n              var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(up.drawings[up.levels[j].price].index), 1)[0]\r\n              options.debug && console.log(bar.length, up.id, 'undraw up line', up.levels[j].price, 'from serie', plotIndexToFree);\r\n              freeSlots.push({\r\n                index: plotIndexToFree,\r\n                redrawAt: bar.length + 1\r\n              })\r\n              boundaries[up.drawings[up.levels[j].price].id] = bar.length - 1\r\n              delete up.drawings[up.levels[j].price]\r\n            }\r\n            \r\n            var level = (levels)[up.levels[j].index]\r\n            up.levels[j].price = up.origin + up.impulse * level\r\n            up.levels[j].level = level\r\n            up.levels[j].upper = up.origin + up.impulse * level\r\n            up.levels[j].lower = up.origin + up.impulse * level\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (up.invalidationIndex === null) {\r\n        up.invalidationIndex = up.levels[up.lowerIndex].index - 1\r\n        var nextLevel = (levels)[up.invalidationIndex]\r\n        up.invalidation = up.origin + up.impulse * (nextLevel === undefined ? (levels)[up.invalidationIndex] : (levels)[up.invalidationIndex] + (atr) * (fibMultUp)[0])\r\n      }\r\n\r\n    } else if (workingClose < up.levels[up.lowerIndex].price) { // move prev\r\n      if (options.debug) { console.log(bar.length, up.id, 'up breakout (prev)', workingClose + ' < ' + up.levels[up.lowerIndex].price) }\r\n\r\n      for (let i = up.levels[up.lowerIndex].index - 1; i >= 0; i--) {\r\n        var lowerPriceLevel = up.origin + up.impulse * levels[i]\r\n\r\n        if (workingClose > lowerPriceLevel) {\r\n          var change = i - up.levels[up.lowerIndex].index // -1\r\n          if (options.debug) { console.log(bar.length, up.id, 'change:', change) }\r\n          if (up.levels[0].index + change < 0 || up.levels[up.levels.length - 1].index + change > levels.length - 1) {\r\n            if (options.debug) { console.log(bar.length, up.id, 'reached levels boundary') }\r\n            break\r\n          }\r\n          up.redrawRequired = true\r\n\r\n          for (var j = 0; j < up.levels.length; j++) {\r\n            up.levels[j].index = up.levels[j].index + change\r\n\r\n            if (j >= change + up.levels.length && up.drawings[up.levels[j].price]) {\r\n              var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(up.drawings[up.levels[j].price].index), 1)[0]\r\n              options.debug && console.log(bar.length, up.id, 'undraw up line', up.levels[j].price, 'from serie', plotIndexToFree);\r\n              freeSlots.push({\r\n                index: plotIndexToFree,\r\n                redrawAt: bar.length + 1\r\n              })\r\n              boundaries[up.drawings[up.levels[j].price].id] = bar.length - 1\r\n              delete up.drawings[up.levels[j].price]\r\n            }\r\n\r\n            var level = (levels)[up.levels[j].index]\r\n            up.levels[j].price = up.origin + up.impulse * level\r\n            up.levels[j].level = level\r\n            up.levels[j].upper = up.origin + up.impulse * level\r\n            up.levels[j].lower = up.origin + up.impulse * level\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // drawer\r\n    if (up.redrawRequired) {\r\n      up.redrawRequired = false\r\n      var missingSlots = 0\r\n      for (var i = 0; i < up.levels.length; i++) {\r\n        if (!up.drawings[up.levels[i].price]) {\r\n          if (freeSlots.length) {\r\n            var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\r\n\r\n            if (!slot) {\r\n              up.redrawRequired = true\r\n              continue\r\n            }\r\n\r\n            up.drawings[up.levels[i].price] = {\r\n              index: slot.index,\r\n              id: 'up-' + up.levels[i].price + time\r\n            }\r\n\r\n            usedSlots.push(freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index)\r\n            options.debug && console.log(bar.length, up.id, 'draw up line', up.levels[i].price, 'using serie', up.drawings[up.levels[i].price].index);\r\n            renderer.indicators[indicatorId].series[up.drawings[up.levels[i].price].index] = {\r\n              time: workingTime,\r\n              color: options.upColor,\r\n              id: up.drawings[up.levels[i].price].id,\r\n              lowerValue: up.levels[i].lower,\r\n              higherValue: up.levels[i].upper,\r\n              extendRight: true,\r\n              label: options.showLabel ? up.levels[i].level : ''\r\n            }\r\n          } else {\r\n            up.redrawRequired = true\r\n            missingSlots = missingSlots + 1\r\n          }\r\n        }\r\n      }\r\n\r\n      if (up.redrawRequired) {\r\n        if (options.debug) { console.log(bar.length, up.id, 'all slots taken, still have to draw', missingSlots, 'lines') }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nif (options.showUp && swingHigh && (swings)[0] > (swings)[2] && (!up.valid || up.origin > (swings)[1])) {\r\n  var upId = 'up' + bar.length\r\n\r\n  /*pendingMarkers.push({\r\n    time: workingTime,\r\n    position: 'belowBar',\r\n    color: options.debugColor,\r\n    text: 'üî∫' + (options.debug ? upId : ''),\r\n  })*/\r\n\r\n  if (up.active) {\r\n    // active if opposite side didn't stopped it (happens when singleSide is disabled)\r\n    boundaries[up.id] = bar.length - 1\r\n    for (let i = 0; i < up.levels.length; i++) {\r\n      if (up.drawings[up.levels[i].price]) {\r\n        var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(up.drawings[up.levels[i].price].index), 1)[0]\r\n        options.debug && console.log(bar.length, up.id, 'undraw up line (trend override)', up.levels[i].price, 'from serie', plotIndexToFree);\r\n        freeSlots.push({\r\n          index: plotIndexToFree,\r\n          redrawAt: bar.length + 1\r\n        })\r\n        boundaries[up.drawings[up.levels[i].price].id] = bar.length - 1\r\n        delete up.drawings[up.levels[i].price]\r\n      }\r\n    }\r\n  }\r\n\r\n  var a = (swings)[1]\r\n  var b = (swings)[0]\r\n\r\n  // define current up trend\r\n  up = {\r\n    active: true, // active drawing\r\n    valid: true,\r\n    timestamp: workingTime,\r\n    id: upId,\r\n    origin: a,\r\n    neckline: b,\r\n    impulse: b - a,\r\n    target: a + (b - a) * (options.targetLevelUp),\r\n    invalidation: a + (b - a) * (options.maxRetracement),\r\n    invalidationIndex: 0,\r\n    levels: [],\r\n    drawings: {},\r\n    redrawRequired: true,\r\n  }\r\n\r\n  var fromIndex = Math.max(baseLevelIndex - options.drawCount, 0)\r\n  var toIndex = fromIndex + options.drawCount * 2 - 1\r\n  up.lowerIndex = options.drawCount - 1\r\n  up.higherIndex = options.drawCount\r\n\r\n  for (let i = fromIndex; i <= toIndex; i++) {\r\n    var level = (levels)[i]\r\n    up.levels.push({\r\n      index: i,\r\n      price: up.origin + up.impulse * level,\r\n      upper: up.origin + up.impulse * level,\r\n      lower: up.origin + up.impulse * level,\r\n      level: level,\r\n    })\r\n  }\r\n}\r\n\r\n// set reference to bar index : avoid process next tick\r\nlastIndex = bar.length\r\n\r\n// 1-* = trend levels (slots)\r\nif (renderer.indicators[indicatorId].series[1]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[2]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[3]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[4]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[5]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[6]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[7]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[8]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[9]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[10]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[11]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[12]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[13]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[14]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[15]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[16]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[17]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[17] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[18]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[18] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[19]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[19] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[20]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[20] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[21]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[21] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[22]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[22] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[23]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[23] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[24]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[24] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[25]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[25] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[26]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[26] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[27]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[27] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[28]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[28] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[29]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[29] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[30]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[30] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[31]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[31] || { time: time }, strokeWidth = options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[32]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[32] || { time: time }, strokeWidth = options.strokeWidth)\r\n}",
    "createdAt": 1681762354133,
    "updatedAt": 1704925651415,
    "displayName": "Fibonacci Grid",
    "description": "Auto Fibonacci Levels indicator",
    "author": "aggr"
  }
}