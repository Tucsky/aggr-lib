{
  "type": "indicators",
  "name": "indicators:Fibonacci Grid",
  "data": {
    "id": "fibonacci-grid",
    "name": "Fibonacci Grid",
    "options": {
      "priceScaleId": "right",
      "levels": "0|1|2|3|5|8|13|21|34|55|89",
      "levelMult": 1,
      "drawCount": 3,
      "srcExchange": 0,
      "srcQuote": 0,
      "srcType": "perp",
      "targetLevelUp": 79,
      "invalidationThreshold": 0,
      "enableInvalidation": 0,
      "invalidateSwing": true,
      "useHeikinAshi": 0,
      "useGaps": true,
      "showUp": true,
      "enableTarget": true,
      "showLabel": 0,
      "lineWidth": 1.5,
      "upColor": "rgb(255,235,59)"
    },
    "script": "levels = option(default=\"0|1|2|3|5|8|13|21|34|55|89\",type=\"text\")\nlevelMult = option(default=\"1\",type=\"text\")\ndrawCount = option(type=range,min=1,max=6,default=3,step=1)\nsrcExchange = option(type=exchange,rebuild=true)\nsrcQuote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\nsrcType = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\ntargetLevelUp = option(type=range,min=0,max=89,default=79)\ninvalidationThreshold = option(type=range,max=2,min=0,step=0.01)\nenableInvalidation = option(type=checkbox)\ninvalidateSwing = option(type=checkbox,default=true)\nuseHeikinAshi = option(type=checkbox)\nuseGaps = option(type=checkbox,default=true)\nshowUp = option(type=checkbox,default=true)\nenableTarget = option(type=checkbox,default=true)\nshowLabel = option(type=checkbox)\nlineWidth = option(default=1.5)\nupColor = option(type=color,default=\"rgb(255,235,59)\")\n\n// <STARTUP SCRIPT> \nif (!pendingMarkers) {\n  // runs only once\n  markers = []\n  pendingMarkers = []\n  lastIndex = null\n  freeSlots = []\n  usedSlots = []\n  swings = []\n  rawLevels = options.levels.toString().split(/,|\\|/).map(a => +a)\n  baseLevelIndex = rawLevels.indexOf(0)\n  up = {}\n  boundaries = {}\n  var mults = levelMult.toString().split(/,|\\|/).map(a => +a)\n  levels = rawLevels.reduce((acc, level, index, arr) => {\n    return mults.reduce((acc2, val) => {\n      arr[index + 1] && acc2.push(+(level + (arr[index + 1] - level) * val).toFixed(3));\n      return acc2\n    }, acc)\n  }, [rawLevels[0]])\n  for (var i = 1; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    freeSlots.push({\n      index: i,\n      redrawAt: 0\n    })\n\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n// </STARTUP SCRIPT> \n\n// <MARKERS.UTILS> \nif (pendingMarkers.length) {\n  markers = markers.concat(pendingMarkers)\n  if (series[0].setMarkers) {\n    series[0].setMarkers(markers)\n  }\n  pendingMarkers = []\n}\n// </MARKERS.UTILS>\n\n// process only on new candle\nif (bar.length === lastIndex) {\n  return\n}\nsrc = options.srcExchange || options.srcType || options.srcQuote ? source(type=options.srcType, exchange=options.srcExchange, quote=options.srcQuote) : bar\n\nif (!src) {\n  return\n}\nprice = options.useHeikinAshi ? avg_heikinashi(src) : options.useGaps ? avg_ohlc_with_gaps(src) : avg_ohlc(src)\ncandlestick(price, upColor=transparent, downColor=transparent, wickUpColor=transparent, wickDownColor=transparent, showBorders=false) // ghost price for markers\n\n// constants and working values\nopen = price.open\nclose = price.close\nhigh = price.high\nlow = price.low\nvar workingClose = close[1]\nvar workingOpen = open[1]\nvar workingHigh = high[1]\nvar workingLow = low[1]\nvar workingTime = time\nvar swingHigh = workingClose > workingOpen && close <= open ? Math.min(open, workingClose) : null\nvar swingLow = workingClose < workingOpen && close >= open ? Math.max(open, workingClose) : null\n\nif (swingHigh || swingLow) {\n  swings.unshift(swingHigh || swingLow)\n  if (swings.length > 4) {\n    swings.pop()\n  }\n}\n\nif (options.showUp) {\n  if (up.valid) {\n    // up trend origin broken ‚ùå\n    if (options.enableInvalidation && (options.invalidateSwing ? swingHigh && swingHigh < up.invalidation : workingClose < up.invalidation)) {\n      // deactivate trend\n      up.valid = false\n    }\n  \n    // up trend target reached üí∞\n    if (options.enableTarget && high[1] >= up.target) {\n      up.valid = false\n      pendingMarkers.push({\n        time: time,\n        position: 'aboveBar',\n        text: 'üí∞'\n      })\n    }\n  }\n\n  // in active up trend process\n  if (up.active) {\n\n    // ranges breakout\n    if (workingClose > up.levels[up.higherIndex].price) { // move next\n      for (let i = up.levels[up.higherIndex].index + 1; i < levels.length; i++) {\n        var higherPriceLevel = up.origin + up.impulse * levels[i]\n\n        if (workingClose < higherPriceLevel) {\n          var change = i - up.levels[up.higherIndex].index // +1\n          if (up.levels[0].index + change < 0 || up.levels[up.levels.length - 1].index + change > levels.length - 1) {\n            break\n          }\n          up.redrawRequired = true\n\n          for (var j = 0; j < up.levels.length; j++) {\n            up.levels[j].index = up.levels[j].index + change\n\n\n            if (j < change && up.drawings[up.levels[j].price]) {\n              // level out of scope\n              var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(up.drawings[up.levels[j].price].index), 1)[0]\n              freeSlots.push({\n                index: plotIndexToFree,\n                redrawAt: bar.length + 1\n              })\n              boundaries[up.drawings[up.levels[j].price].id] = bar.length - 1\n              delete up.drawings[up.levels[j].price]\n            }\n            \n            var level = (levels)[up.levels[j].index]\n            up.levels[j].price = up.origin + up.impulse * level\n            up.levels[j].level = level\n            up.levels[j].upper = up.origin + up.impulse * level\n            up.levels[j].lower = up.origin + up.impulse * level\n          }\n\n          break;\n        }\n      }\n\n      if (up.invalidationIndex === null) {\n        up.invalidationIndex = up.levels[up.lowerIndex].index - 1\n        var nextLevel = (levels)[up.invalidationIndex]\n        up.invalidation = up.origin + up.impulse * (nextLevel === undefined ? (levels)[up.invalidationIndex] : (levels)[up.invalidationIndex] + (atr) * (fibMultUp)[0])\n      }\n\n    } else if (workingClose < up.levels[up.lowerIndex].price) { // move prev\n      for (let i = up.levels[up.lowerIndex].index - 1; i >= 0; i--) {\n        var lowerPriceLevel = up.origin + up.impulse * levels[i]\n\n        if (workingClose > lowerPriceLevel) {\n          var change = i - up.levels[up.lowerIndex].index // -1\n          if (up.levels[0].index + change < 0 || up.levels[up.levels.length - 1].index + change > levels.length - 1) {\n            break\n          }\n          up.redrawRequired = true\n\n          for (var j = 0; j < up.levels.length; j++) {\n            up.levels[j].index = up.levels[j].index + change\n\n            if (j >= change + up.levels.length && up.drawings[up.levels[j].price]) {\n              var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(up.drawings[up.levels[j].price].index), 1)[0]\n              freeSlots.push({\n                index: plotIndexToFree,\n                redrawAt: bar.length + 1\n              })\n              boundaries[up.drawings[up.levels[j].price].id] = bar.length - 1\n              delete up.drawings[up.levels[j].price]\n            }\n\n            var level = (levels)[up.levels[j].index]\n            up.levels[j].price = up.origin + up.impulse * level\n            up.levels[j].level = level\n            up.levels[j].upper = up.origin + up.impulse * level\n            up.levels[j].lower = up.origin + up.impulse * level\n          }\n\n          break;\n        }\n      }\n    }\n\n    // drawer\n    if (up.redrawRequired) {\n      up.redrawRequired = false\n      var missingSlots = 0\n      for (var i = 0; i < up.levels.length; i++) {\n        if (!up.drawings[up.levels[i].price]) {\n          if (freeSlots.length) {\n            var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\n\n            if (!slot) {\n              up.redrawRequired = true\n              continue\n            }\n\n            up.drawings[up.levels[i].price] = {\n              index: slot.index,\n              id: 'up-' + up.levels[i].price + time\n            }\n\n            usedSlots.push(freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index)\n            renderer.indicators[indicatorId].series[up.drawings[up.levels[i].price].index] = {\n              time: workingTime,\n              color: options.upColor,\n              id: up.drawings[up.levels[i].price].id,\n              lowerValue: up.levels[i].lower,\n              higherValue: up.levels[i].upper,\n              extendRight: true,\n              label: options.showLabel ? up.levels[i].level : ''\n            }\n          } else {\n            up.redrawRequired = true\n            missingSlots = missingSlots + 1\n          }\n        }\n      }\n    }\n  }\n}\n\nif (options.showUp && swingHigh && (swings)[0] > (swings)[2] && (!up.valid || up.origin > (swings)[1])) {\n  var upId = 'up' + bar.length\n\n  if (up.active) {\n    // active if opposite side didn't stopped it (happens when singleSide is disabled)\n    boundaries[up.id] = bar.length - 1\n    for (let i = 0; i < up.levels.length; i++) {\n      if (up.drawings[up.levels[i].price]) {\n        var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(up.drawings[up.levels[i].price].index), 1)[0]\n        freeSlots.push({\n          index: plotIndexToFree,\n          redrawAt: bar.length + 1\n        })\n        boundaries[up.drawings[up.levels[i].price].id] = bar.length - 1\n        delete up.drawings[up.levels[i].price]\n      }\n    }\n  }\n\n  var a = (swings)[1]\n  var b = (swings)[0]\n\n  // define current up trend\n  up = {\n    active: true, // active drawing\n    valid: true,\n    timestamp: workingTime,\n    id: upId,\n    origin: a,\n    neckline: b,\n    impulse: b - a,\n    target: a + (b - a) * (options.targetLevelUp),\n    invalidation: a + (b - a) * (options.invalidationThreshold),\n    invalidationIndex: 0,\n    levels: [],\n    drawings: {},\n    redrawRequired: true,\n  }\n\n  var fromIndex = Math.max(baseLevelIndex - options.drawCount, 0)\n  var toIndex = fromIndex + options.drawCount * 2 - 1\n  up.lowerIndex = options.drawCount - 1\n  up.higherIndex = options.drawCount\n\n  for (let i = fromIndex; i <= toIndex; i++) {\n    var level = (levels)[i]\n    up.levels.push({\n      index: i,\n      price: up.origin + up.impulse * level,\n      upper: up.origin + up.impulse * level,\n      lower: up.origin + up.impulse * level,\n      level: level,\n    })\n  }\n}\n\n// set reference to bar index : avoid process next tick\nlastIndex = bar.length\n\n// 1-* = trend levels (slots)\nif (renderer.indicators[indicatorId].series[1]) {\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[2]) {\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[3]) {\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[4]) {\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[5]) {\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[6]) {\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[7]) {\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[8]) {\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[9]) {\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[10]) {\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[11]) {\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[12]) {\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[13]) {\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[14]) {\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[15]) {\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeWidth = lineWidth)\n}\nif (renderer.indicators[indicatorId].series[16]) {\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeWidth = lineWidth)\n}",
    "createdAt": 1704935468237,
    "updatedAt": 1704935468237,
    "displayName": "Fibonacci Grid",
    "description": "Auto Fibonacci Levels indicator",
    "author": "aggr"
  }
}