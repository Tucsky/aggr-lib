{
  "type": "indicators",
  "name": "indicators:Fibonacci Retracement",
  "data": {
    "id": "fibonacci-retracement",
    "name": "Fibonacci Retracement",
    "options": {
      "priceScaleId": "right",
      "lengthLeft": 50,
      "lengthRight": 50,
      "extendLength": 0,
      "repaint": false,
      "useClose": true,
      "renderInfinite": true,
      "levels": "",
      "strokeWidth": 1
    },
    "script": "// Top to bottom fib retracement levels / extentions\n// 1. identify top and bottom\n// 2. pull a fib sequence (see levels option)\n\n// slots\nbrokenarea(infinite = renderInfinite)\nbrokenarea(infinite = renderInfinite)\nbrokenarea(infinite = renderInfinite)\nbrokenarea(infinite = renderInfinite)\n\n// options\nlengthLeft=option(type=range,default=50,min=3,max=200,step=1,description=\"Left pivot length (look back)\")\nlengthRight=option(type=range,default=50,min=3,max=200,step=1,description=\"Right pivot length (look ahead)\")\nextendLength=option(type=range,min=0,max=2000,log=true,default=0,step=1,description=\"Extend line length (0 = infinite)\")\nrepaint=option(type=checkbox,default=false,description=\"Place line at (current time - lengthRight)\")\nuseClose=option(type=checkbox,default=true,description=\"Use close instead of high and low\")\nrenderInfinite=option(type=checkbox,default=true,description=\"Changing this requires rebuild (toggle on/off)\")\nlevels=option(type=text,description=\"Comma separated list of fib levels (max 4 or see script)\")\ncolorA=option(type=color,default='rgba(255,255,0,0.13)')\ncolorB=option(type=color,default='rgb(255,235,59)')\nstrokeWidth=option(default=1)\n\nif (!boundaries) {\n  lastIndex = null\n  boundaries = {}\n  levelsArr = String(levels || '0,0.618,1.618,4.236').split(/,|\\|/)\n\n  var slots = 0\n  for (let i = 0; i < series.length; i++) {\n    if (series[i].seriesType() === 'BrokenArea') {\n      series[i].setExtensionsBoundaries(boundaries)\n      slots++\n    }\n  }\n\n  maxLevels = Math.min(levelsArr.length, slots)\n}\n\nif (bar.length === lastIndex) {\n  return\n}\n\nvar ph = pivot_high(useClose ? $price.close : $price.high, lengthLeft, lengthRight)\nvar a = 0\nvar b = 0\n\nif (ph && ph != lastPh) {\n  lastPh = ph\n\n  if (bar.length > lengthLeft + lengthRight) {\n    if (lastPl) {\n      a = lastPh\n      b = lastPl\n    }\n  }\n}\n\nvar pl = pivot_low(useClose ? $price.close : $price.low, lengthLeft, lengthRight)\n\nif (pl && pl !== lastPl) {\n  lastPl = pl\n\n  if (bar.length > lengthLeft + lengthRight) {\n    if (lastPh) {\n      a = lastPl\n      b = lastPh\n    }\n  }\n}\n\nif (a && b) {\n  var isLow = b < a\n  var r = isLow ? a - b : b - a\n  var t = time - (repaint ? bar.timeframe * (lengthRight - 1) : 0)\n  lastTimePainted = t\n  paintId = String(Math.random())\n  if (paintId && extendLength > 0) {\n    boundaries[paintId] = bar.length + extendLength\n  }\n\n  for (let i = 0; i < levelsArr.length; i++) {\n    if (!series[i]) {\n      continue\n    }\n    var level = levelsArr[i]\n    ext = a + r * level * (isLow ? -1 : 1)\n    bar.series[series[i].id] = {\n      id: paintId,\n      time: t,\n      higherValue: ext,\n      lowerValue: ext,\n      extendRight: true,\n      color: interpolate(i / maxLevels, colorA, colorB)\n    }\n  }\n}\n\n// set reference to bar index : only process first bar of tick\nlastIndex = bar.length",
    "createdAt": 1708646152650,
    "updatedAt": 1708647542072,
    "displayName": "Fibonacci Retracement",
    "description": "",
    "author": "aggr"
  }
}